use rusqlite::{Connection, params, NO_PARAMS, Rows};
use chrono::{DateTime, Local};

use crate::db::*;

/*

Note::get_all(conn).filter_map(|note| note.title.contains("Web")).collect()

let query = Query::new()
    .add_where(Equal("title", "Day 12"))
    .add_order(Ascending("noteid"))
    .add_limit(10)

for data in Note::query(conn, query) {
    println("{}", row)
}

*/

#[derive(Debug, PartialEq)]
pub struct Note {
    pub title: String,
    pub created: DateTime<Local>,
    pub text: String,
}

impl Note {
    pub fn new(title: &str, text: &str) -> Note {
        Note {
            title: title.to_string(),
            created: Local::now(),
            text: text.to_string(),
        }
    }
    
    // Encoding / decoding
}

impl Table for Note {
    type Row = Note;

    fn get_all<'a>(conn: &mut Connection) -> Result<Vec<Note>, TableError<'a>> {
        Ok(
            conn.prepare("SELECT * FROM notes")?
                .query_map(NO_PARAMS, |row| { 
                    Ok(Note {
                        title: row.get(0)?,
                        created: row.get(1)?,
                        text: row.get(2)?,
                    })
                })?
                .filter_map(Result::ok)
                .collect()
        )
    }

    fn insert<'a>(conn: &mut Connection, row: Note) -> Result<(), TableError<'a>> {
         conn.execute("INSERT INTO notes (title, time, text) VALUES (?1, ?2, ?3)",
            params![row.title, row.created, row.text])?;
         Ok(())
    }

    fn delete<'a>(conn: &mut Connection, row: Note) -> Result<(), TableError<'a>> {
        conn.execute("DELETE FROM notes WHERE title = ?1, time = ?2, text = ?3",
            params![row.title, row.created, row.text])?;
        Ok(())
    }

    fn query<'a>(conn: &mut Connection, query: Query) -> Result<Vec<Note>, TableError<'a>> {
        let query_string = &(String::from("SELECT * FROM notes ") + &query.to_sql());
        Ok(
            conn.prepare(query_string)?
                .query_map(NO_PARAMS, |row| {
                    Ok(Note {
                        title: row.get(0)?,
                        created: row.get(1)?,
                        text: row.get(2)?,
                    })
                })?
                .filter_map(Result::ok)
                .collect()
        )
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn get_mock_db() -> Connection {
        let conn = Connection::open("test.db");

        conn.execute(
            "CREATE TABLE IF NOT EXISTS notes (
                id INTEGER PRIMARY KEY,
                title TEXT NOT NULL UNIQUE,
                created TEXT NOT NULL,
                text TEXT NOT NULL
                )"
        );

        conn.execute("INSERT INTO notes (title created text) VALUES (?1 ?2 ?3)",
            params![String::from("Day 12"), Local::now(), String::from("Today's diary...")]);

        conn
    }

    #[test]
    fn get_all() {
        let note = Note::new("Day 12", "Today's diary...");
        let conn = get_mock_db();
        let db_note = Note::get_all(&mut conn).get(0);

        assert_eq!(note, db_note);
    }
}
